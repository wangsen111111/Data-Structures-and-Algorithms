package com.company;
/*
程序调用自身的编程技巧称为递归（ recursion）：
  递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为
  一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
回溯思路：
  回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
  回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，
  这种走不通就退回再走的技术为回溯法。

回溯的思路基本如下：当前局面下，我们有若干种选择，所以我们对每一种选择进行尝试。如果发现某种选择违反了某些限定条件，此时 return；
如果尝试某种选择到了最后，发现该选择是正确解，那么就将其加入到解集中。
在这种思想下，我们需要清晰的找出三个要素：选择 (Options)，限制 (Restraints)，结束条件 (Termination)。
用一个比较通俗的说法来解释递归和回溯：

我们在路上走着，前面是一个多岔路口，因为我们并不知道应该走哪条路，所以我们需要尝试。尝试的过程就是一个函数。
我们选择了一个方向，后来发现又有一个多岔路口，这时候又需要进行一次选择。所以我们需要在上一次尝试结果的基础上，
再做一次尝试，即在函数内部再调用一次函数，这就是【递归】的过程。
这样重复了若干次之后，发现这次选择的这条路走不通，这时候我们知道我们上一个路口选错了，所以我们要回到上一个路口重新选择其他路，这就是【回溯】的思想。
 */
/*
6.1递归的应用场景：
   看个实际应用场景，迷宫问题(回溯)， 递归(Recursion)
6.2递归的概念：
    简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.
    递归有助于编程者解决复杂的问题,同时 可以让代码变得简洁。
6.3递归调用机制：
    1,当程序执行到一个方法时，就会开辟一个独立的空间（栈）
    2，每个空间的数据（局部变量），是独立的

 */

public class Main {

    public static void main(String[] args) {
        test(3);
        System.out.println("3的阶乘为："+factorial(3));
    }
    /*
    递归的调用机制：通过打印问题，回顾递归调用机制
    图解：打印问题回顾递归调用机制.png
    递归的调用规则：
               1，当程序执行到一个方法时，就会开辟一个独立的空间（栈帧）
               2，每个空间的数据（局部变量），是独立的（比如图解中：每个栈帧都有一个n变量，互不影响）
               3，递归的一个方法执行完毕，或者遇到ruturn，就会返回到调用该方法的地方
     */
    public static void test(int n){
        if(n>2){
            test(n-1);
        }
        System.out.println("n="+n);
    }
    /*
    阶乘问题
     */
    public static int factorial(int n){
        if(n==1){
            return 1;
        }else{
            return factorial(n-1)*n;
        }
    }
    /*
    递归用于解决什么样的问题 1) 各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛)
                        2) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
                        3) 将用栈解决的问题-->递归代码比较简洁
     */
    /*
    递归需要遵守的重要规则：
     1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
        *
        递归的底层用到了栈，当程序执行到一个方法时，就会开辟一个独立的空间（栈空间），它是独立的，好像把每个空间放到一个大的栈里面去，每次执行的时候
        是把新的栈压在栈顶，当然执行也是从上面开始执行的，执行完了回到下一个栈，最后回到栈低，main栈的时候，程序结束，递归的底层、递归编译器的底层
        用到了栈的机制
        *
     2) 方法的局部变量是独立的，不会相互影响, 比如 n 变量
     3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据，（迷宫问题，让多个栈共享同一个数组，不管调用产生多少个栈，都是修改同一张
        地图）
     4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死递归了:（比如打印问题中test(n-1)）
              不停的递归，出现栈溢出（StackOverflowError）
     5) 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕
     */
}
